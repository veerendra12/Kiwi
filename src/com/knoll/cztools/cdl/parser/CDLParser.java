/* Generated By:JJTree&JavaCC: Do not edit this line. CDLParser.java */
package com.knoll.cztools.cdl.parser;

import com.sun.java.util.collections.ArrayList;
import com.sun.java.util.collections.Iterator;
import com.sun.java.util.collections.LinkedList;
import com.sun.java.util.collections.List;

import java.io.CharArrayReader;
import java.io.InputStream;
import java.io.Reader;
import java.io.StringReader;
import java.util.Stack;

public class CDLParser/*@bgen(jjtree)*/implements CDLParserTreeConstants, CDLParserConstants {/*@bgen(jjtree)*/
  protected JJTCDLParserState jjtree = new JJTCDLParserState();
  //this code is currently not thread-safe  
  private LinkedList m_roots;
  private int m_globalSequence;

  /* parse types */
  private static final int STATEMENTS = 0;
  private static final int EXPRESSION = 1;
  public static boolean DEBUG_MODE = false;
  public static final String CDL_DEBUG =  "cz.cdl_debug";
  private static CDLParser sCDLParser = new CDLParser();  
  
  static {
    String value =  System.getProperty(CDL_DEBUG);
    DEBUG_MODE = value != null ? value.equalsIgnoreCase("true") : false;
  }
  
  public static CDLParser getInstance() {
	  return sCDLParser;
  }

  public static void main(String[] args) throws ParseException {
	  CDLParser cdlParser = new CDLParser();
	  String cdlText = "CONTRIBUTE 'X' TO 'Y';";
	  cdlParser.parseStatements(new StringReader(cdlText));
	  System.out.println("Done Parsing!");
  }
  
  
  public CDLParser()
  {
    //just feed it an empty stream
    this(new CharArrayReader(new char[] {}));
    m_roots = new LinkedList();
    m_globalSequence = 0;
  }

  public int getNextSequence()
  {
    return ++m_globalSequence;
  }

  /**
  * This is the public method for rule creation
  * Pass a stream representing CDL text and 
  * the expression tree will be created in memory
  */
  public ParseResult parseStatements(InputStream stream) throws ParseException
  {
    ReInit(stream);
    return parseInternal(STATEMENTS, true);
  }

  /**
  * This is the public method for rule creation
  * Pass a Reader representing CDL text and 
  * the expression tree will be created in memory
  * If the writeToDb argument is true and the statements parse correctly,
  * they will be written to the cz_expression_nodes table
  */
  public ParseResult parseStatements(Reader reader) throws ParseException
  {
    ReInit(reader);
    return parseInternal(STATEMENTS, false);
  }

  /**
  * This is the public method for creating single 
  * expressions, such as to pass as an argument to
  * a functional companion.
  * Pass a stream representing CDL text and
  * the expression tree will be created in memory
  * If the writeToDb argument is true and the statements parse correctly,
  * they will be written to the cz_expression_nodes table
  */
  public ParseResult parseExpression(Reader reader, boolean writeToDb) throws ParseException
  {
    ReInit(reader);
    return parseInternal(EXPRESSION, writeToDb);
  }

  /**
  * This actually starts the parsing, using the appropriate entry point
  * for the grammar
  */
  private ParseResult parseInternal(int parseType, boolean writeToDb) throws ParseException
  {
    m_roots.clear();
    m_globalSequence = 0;
    // getModelAdapter().clearRecords(); //get rid of the current rule
    try{
      switch(parseType){
        case STATEMENTS:
          Statements();
          break;
        case EXPRESSION:
          Expression();
          break;
      }
      checkTypes(parseType==STATEMENTS);
    }catch(ParseException pe){
      //make sure it has the adapter for message translating
      // pe.setModelAdapter(getModelAdapter()); 
      throw pe;
    }catch(TokenMgrError tme){
      //if this is anything other than a lexical error, it is a fatal error not meant
      //for the user
      if(!tme.isLexicalError()){
        throw new RuntimeException(tme.getMessage());
      }
      //make sure it has the adapter for message translating
      // tme.setModelAdapter(getModelAdapter()); 
      throw tme;
    }
    if(writeToDb) {
      for(Iterator iter=m_roots.iterator(); iter.hasNext();) {
        ExprNode node = (ExprNode)iter.next();
        if(node.getExprType() ==  ExprNode.EXPR_CALL ||
           node.getExprType() == CDLParserTreeConstants.JJTEXPR_CALL) {
          // getModelAdapter().setEventBindingValues(node);
          break;
        } else {
          node.write();
        }
      }
    }
    return createResult();
  }

  private ParseResult createResult() {
    ParseResult pr = new ParseResult();
    /*    
    // Go over the roots and see if we have an Accumulator type template
    List roots = getRoots();
    for(Iterator iterator = roots.iterator();iterator.hasNext();) {
      ExprNode root = (ExprNode) iterator.next();
      int type = root.getExprType();
      if( type == ExprNode.EXPR_COMPATIBLE ) {
        pr.setIsCompatibilityStatement(true);
      }
      else {
        if(type == ExprNode.EXPR_FOR_ALL || type == ExprNode.EXPR_FOR_DISTINCT ) {
          root = (ExprNode)root.jjtGetChild(root.jjtGetNumChildren()-1);
        }
        Integer templateId = root.getTemplateId();
        if(templateId != null) {
          Template template = m_modelAdapter.getTemplate(templateId);
          if( template != null && template.isSearchOrDefaultOnlyTemplate()) {
            pr.setIsDefaultOrSearchOnlyStatement(true);
            pr.setDefaultOrSearchOperator(template.getName().toUpperCase());
          }
          if(template != null && template.isAccumulatorType()) {
            pr.setIsAccumulatorStatement(true);
          }
        }
      }
    }
    */
    return pr;
  }

  public void commit(){
    // getModelAdapter().commit();
  }

  private List getRoots()
  {
    if(m_roots.isEmpty()) {
      while (jjtree.nodeArity() > 0) {
        m_roots.addFirst(jjtree.popNode());
      }
    }
    return m_roots;
  }

  /**
  * This method handles type checking and other symatnic analysis
  */
  private void checkTypes(boolean isStatement) throws ParseException
  {
 
  }
  /**
    Last node of refer (Reference()) must be a sysProp with a CollectionFlag
    or TemplateApp must return Collection Flag
  */
  void validateCollection(ExprNode refer, ExprNode exprNode, boolean isTempAppl) throws ParseException {
//    try {
//      if(isTempAppl) {
//        if("1".equals(exprNode.getReturnsCollection())) {
//          throw new ParseException("TemplateAppliction does not have Collection Flag", refer);
//        }
//        return;
//      }
//     int exprType = exprNode.getExprType();
//     /**
//      For EXPR_SYS_PROP try to do an early TypeChecking and propagate the collectionFlag
//      to the Reference node. This will make the code simpler since we have
//      to look for just CollectionFlag on the Reference
//     */
//     if(exprType == ExprNode.EXPR_SYS_PROP) {
//       String propertyName = exprNode.getName();
//       Template template =  getModelAdapter().getSystemProperty(propertyName,null );
//       boolean isCollection = template.getReturnsCollection();
//       if(!isCollection || exprNode.jjtGetNumChildren() >0 ) throw new ParseException("invalid usage-- not allowed", refer);
//       exprNode.setReturnsCollection(isCollection);
//     } else if(exprNode.jjtGetNumChildren() == 1) {
//       for(int i=0; i<exprNode.jjtGetNumChildren(); i++){
//         ExprNode childNode = (ExprNode)exprNode.jjtGetChild(i);
//         validateCollection(refer,childNode,isTempAppl );
//       }
//     } else {
//        MessageToken mt = new MessageToken("REFERENCE", "INVALID:-------");
//        String mess ="Collection property not found. ";
//        throw new ParseException(mess, refer);
//     }
//   } catch(InvalidReferenceException ire) {
//     MessageToken mt = new MessageToken("REFERENCE", ire.getPathString());
//     String mess = getModelAdapter().translateMessage("CZ", ire.getMessageName(), new MessageToken[]{mt});
//     ire.setErrorCause(mess);
//     ire.setSourceInfo(exprNode);
//     throw ire;
//   }
 }
  public void printTree() throws ParseException
  {
    //CZUtilities.dumpMessage("---------------\nExpression Tree\n---------------");
    if(m_roots == null) return;

    ASTPrintVisitor visitor = new ASTPrintVisitor();
    for(Iterator iter = m_roots.iterator(); iter.hasNext();) {
      ExprNode root = (ExprNode)iter.next();
      root.jjtAccept(visitor, "  ");
      //CZUtilities.dumpMessage("");
      root.dump(" ");
    }
  }

  class ASTPrintVisitor implements CDLParserVisitor
  {
    public Object visit(SimpleNode node, Object data) throws ParseException{
      ExprNode exprNode = (ExprNode) node;
      //CZUtilities.dumpMessage(data + (exprNode.isRoot() ? "" : " |_ ") + node);
      data = node.childrenAccept(this, data + (exprNode.isRoot() ?
                                               "" :
                                               (exprNode.isLastChild() ?
                                                "    " :
                                                " |  ")));
      return data;
    }
  }

  void jjtreeOpenNodeScope(Node node) {
  }

  void jjtreeCloseNodeScope(Node node) throws ParseException {
    //if the node is of type ref_node, we will look up the ps_node id
    //and explosion node id and then shrink the tree
    ExprNode exprNode = (ExprNode)node;
    switch(exprNode.getExprType()) {
      case ExprNode.EXPR_REFNODE:
        //build name path
        ArrayList path = new ArrayList();
        for(int i=0; i<exprNode.jjtGetNumChildren(); i++){
          ExprNode childNode = (ExprNode)exprNode.jjtGetChild(i);
          if(childNode.getASTType() != CDLParserTreeConstants.JJTEXPR_PSNODE) break;
          path.add(childNode.getName());
        }

        if(!path.isEmpty()){

        } else {
          //this reference begins with an argument reference
          //lets transfer the arg value to the ref node
          ExprNode firstChild = (ExprNode)exprNode.jjtGetChild(0);
          exprNode.setArgument(firstChild.getArgumentName());
          //now delete the arg child
          exprNode.jjtRemoveFirstChildren(1);
          //finally, set the type of the ref node to argument
          exprNode.setAstType(CDLParserTreeConstants.JJTEXPR_ARGUMENT);
        }
        break;
      case ExprNode.EXPR_COMPATIBLE:
        checkAndModifyCompatible(exprNode);
        break;
    }

    //set the sequence number on all the children
    for(int i=0; i<exprNode.jjtGetNumChildren(); i++){
      ExprNode childNode = (ExprNode)exprNode.jjtGetChild(i);
      childNode.setChildSequenceNumber(i+1);
    }
    //if this node has no child sequence, it must be a root, so set its seq to 1
    if(exprNode.getChildSequenceNumber() == null) exprNode.setChildSequenceNumber(1);
  }


  private String pathToName(List path)
  {
    StringBuffer buf = new StringBuffer();
    for(Iterator iter = path.iterator(); iter.hasNext();){
      buf.append((String)iter.next());
      if(iter.hasNext()) buf.append(".");
    }
    return buf.toString();
  }

  /**
  * build a chain of the last n elements in the stack so 
  * that we will assign them the same param index if they are used 
  * as an argument to a template
  * i.e. foo(1, {2, 3});
  * this will parse as:
  *    foo
  *     |__1
  *     |__2
  *     |__3
  * but 2 and 3 will get the same index number, so we will know the difference
  */
  void chainElements(int numElements)
  {
    //put the nodes in a temporary stack
    Stack elements = new Stack();
    while (numElements-- > 0) {
      elements.push(jjtree.popNode());
    }

    //chain the nodes and put them back on the real stack
    ExprNode prevNode = null;
    while (!elements.empty()) {
      ExprNode node = (ExprNode) elements.pop();
      if(prevNode != null) node.setPrevNode(prevNode);
      prevNode = node;
      jjtree.pushNode(node);
    }
  }

  /**
   * for each reference after the "OF" in a compatible, we need to check that
   * it is an option feature or option class and then ti add 
   * a .children() to the end of it
   */
  private void checkAndModifyCompatible(ExprNode compatNode) throws ParseException{
    for(int i=0; i<compatNode.jjtGetNumChildren(); i++) {
      ExprNode iterNode = (ExprNode)compatNode.jjtGetChild(i);
      if(iterNode.getASTType() == CDLParserTreeConstants.JJTEXPR_ITERATOR) {
        ExprNode psNode = (ExprNode)iterNode.jjtGetChild(0);
        if(psNode.jjtGetNumChildren() > 0) {
          String mess = "CZ_CDL_COMPAT_NEEDS_FEAT";
//          throw new ParseException(mess, psNode);
        }
        ExprNode newChild = (ExprNode)psNode.jjtCreate(this, CDLParserTreeConstants.JJTEXPR_SYS_PROP);
        newChild.setName("options");
        newChild.setChildSequenceNumber(1);
        newChild.jjtSetParent(psNode);
        psNode.jjtAddChild(newChild, 0);
      }
    }
  }

  /**
  * Validate that CALL statements exists only for Cxs (rule_type=300)
  * and other statements exist only for non-cx rules (rule_type =200)
  */
  void validateRuleType(ExprNode root) throws ParseException
  {
    if(root.isCXRule()) {
      if(root.getExprType() == CDLParserTreeConstants.JJTEXPR_CALL ||
         root.getExprType() == ExprNode.EXPR_CALL ) {
        return;
      }
    } else if(root.getExprType() != CDLParserTreeConstants.JJTEXPR_CALL) {
      return;
    }
    String mess = "CZ_CDL_NO_TOP_LEVEL_TEMPLATE";
    throw new ParseException(mess, root);
  }

  /**
  * If we are evaluating a statement, there must be a valid top-level template at
  * the root
  */
  void checkRootIsStatement(ExprNode root) throws ParseException
  {
    int type = root.getExprType();
    if(type == ExprNode.EXPR_COMPATIBLE) return;
    if(type == CDLParserTreeConstants.JJTEXPR_CALL) return;
    if(type == ExprNode.EXPR_CALL ) return;
    if(type == ExprNode.EXPR_FOR_ALL || type == ExprNode.EXPR_FOR_DISTINCT ) {
      root = (ExprNode)root.jjtGetChild(root.jjtGetNumChildren()-1);
    }
//    Integer templateId = root.getTemplateId();
//    if(templateId != null) {
//      Template template = m_modelAdapter.getTemplate(templateId);
//      if(template != null && template.isTopLevelTemplate()) return;
//    }
    String mess = "CZ_CDL_NO_TOP_LEVEL_TEMPLATE";
    throw new ParseException(mess, root);
  }

    /*given a string treat "\" as an escape character
   returned value is string value without escape 
   character \ except of course \\ -> \
  */
  private String processEscapeChar(String node) {
    if(node.indexOf("\u005c\u005c") == -1 ) return node;
    StringBuffer newNode = new StringBuffer();
    boolean skipNext = false;
    for(int j = 0; j < node.length(); j++ ) {
      char c = node.charAt(j);
      if(c != '\u005c\u005c') {
        newNode.append( c);
      } else {
        //character is backslash so include it only if previous char is backslash
        if( j != 0) {
          char p = node.charAt(j -1);
          if(p == '\u005c\u005c'  && !skipNext) {
            newNode.append( c);
            skipNext = true;
          } else {
            skipNext = false;
          }
        } else {skipNext = false;}
      }
    }
    return newNode.toString();
  }

/* Main Grammar Productions */
  final public void Statements() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TEXT_LITERAL:
    case INTEGER_LITERAL:
    case DECIMAL_LITERAL:
    case BOOLEAN_LITERAL:
    case PLUS:
    case MINUS:
    case NOT:
    case NOTTRUE:
    case CONSTRAIN:
    case ADD:
    case SUBTRACT:
    case CONTRIBUTE:
    case COMPATIBLE:
    case CALL:
    case LPAREN:
    case LBRACKET:
    case SYSTEM_PARAMETER:
    case EVENT_PARAMETER:
    case SIMPLE_IDENTIFIER:
    case FORMAL_IDENTIFIER:
    case QUOTED_IDENTIFIER:
      Statement();
      break;
    default:
      jj_la1[0] = jj_gen;
      ;
    }
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SEMICOLON:
        ;
        break;
      default:
        jj_la1[1] = jj_gen;
        break label_1;
      }
      jj_consume_token(SEMICOLON);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TEXT_LITERAL:
      case INTEGER_LITERAL:
      case DECIMAL_LITERAL:
      case BOOLEAN_LITERAL:
      case PLUS:
      case MINUS:
      case NOT:
      case NOTTRUE:
      case CONSTRAIN:
      case ADD:
      case SUBTRACT:
      case CONTRIBUTE:
      case COMPATIBLE:
      case CALL:
      case LPAREN:
      case LBRACKET:
      case SYSTEM_PARAMETER:
      case EVENT_PARAMETER:
      case SIMPLE_IDENTIFIER:
      case FORMAL_IDENTIFIER:
      case QUOTED_IDENTIFIER:
        Statement();
        break;
      default:
        jj_la1[2] = jj_gen;
        ;
      }
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case END:
      jj_consume_token(END);
      break;
    case 0:
      jj_consume_token(0);
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void Statement() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TEXT_LITERAL:
    case INTEGER_LITERAL:
    case DECIMAL_LITERAL:
    case BOOLEAN_LITERAL:
    case PLUS:
    case MINUS:
    case NOT:
    case NOTTRUE:
    case CONSTRAIN:
    case LPAREN:
    case LBRACKET:
    case SYSTEM_PARAMETER:
    case EVENT_PARAMETER:
    case SIMPLE_IDENTIFIER:
    case FORMAL_IDENTIFIER:
    case QUOTED_IDENTIFIER:
      Constraint();
      break;
    case CONTRIBUTE:
      Contribute();
      break;
    case COMPATIBLE:
      Compatible();
      break;
    case CALL:
      Call();
      break;
    case ADD:
      Add();
      break;
    case SUBTRACT:
      Subtract();
      break;
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void Constraint() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CONSTRAIN:
      jj_consume_token(CONSTRAIN);
      break;
    default:
      jj_la1[5] = jj_gen;
      ;
    }
    ConstrainingExpression();
  }

  final public void ConstrainingExpression() throws ParseException {
    Expression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case REQUIRES:
    case IMPLIES:
    case EXCLUDES:
    case NEGATES:
    case DEFAULTS:
        SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTEXPR_OPERATOR);
        boolean jjtc001 = true;
        jjtree.openNodeScope(jjtn001);
        jjtreeOpenNodeScope(jjtn001);
      try {
        ConstrainingOperator();
                                             ((ExprNode) jjtn001).setName(getToken(0).image);
        Expression();
      } catch (Throwable jjte001) {
        if (jjtc001) {
          jjtree.clearNodeScope(jjtn001);
          jjtc001 = false;
        } else {
          jjtree.popNode();
        }
        if (jjte001 instanceof RuntimeException) {
          {if (true) throw (RuntimeException)jjte001;}
        }
        if (jjte001 instanceof ParseException) {
          {if (true) throw (ParseException)jjte001;}
        }
        {if (true) throw (Error)jjte001;}
      } finally {
        if (jjtc001) {
          jjtree.closeNodeScope(jjtn001,  2);
          jjtreeCloseNodeScope(jjtn001);
        }
      }
      break;
    default:
      jj_la1[6] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FORALL:
      ForAll();
      break;
    default:
      jj_la1[7] = jj_gen;
      ;
    }
  }

  final public void ConstrainingOperator() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case REQUIRES:
      jj_consume_token(REQUIRES);
      break;
    case IMPLIES:
      jj_consume_token(IMPLIES);
      break;
    case EXCLUDES:
      jj_consume_token(EXCLUDES);
      break;
    case NEGATES:
      jj_consume_token(NEGATES);
      break;
    case DEFAULTS:
      jj_consume_token(DEFAULTS);
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void Contribute() throws ParseException {
    SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTEXPR_OPERATOR);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);
    try {
      jj_consume_token(CONTRIBUTE);
                                          ((ExprNode) jjtn001).setName(getToken(0).image);
                                          ((ExprNode) jjtn001).setInfixOperatorFlag(false);
      Expression();
      jj_consume_token(TO);
      Reference();
    } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte001;}
    }
    if (jjte001 instanceof ParseException) {
      {if (true) throw (ParseException)jjte001;}
    }
    {if (true) throw (Error)jjte001;}
    } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001,  true);
      jjtreeCloseNodeScope(jjtn001);
    }
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FORALL:
      ForAll();
      break;
    default:
      jj_la1[9] = jj_gen;
      ;
    }
  }

  final public void Subtract() throws ParseException {
    SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTEXPR_OPERATOR);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);
    try {
      jj_consume_token(SUBTRACT);
                                        ((ExprNode) jjtn001).setName(getToken(0).image);
                                          ((ExprNode) jjtn001).setInfixOperatorFlag(false);
      Expression();
      jj_consume_token(FROM);
      Reference();
    } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte001;}
    }
    if (jjte001 instanceof ParseException) {
      {if (true) throw (ParseException)jjte001;}
    }
    {if (true) throw (Error)jjte001;}
    } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001,  true);
      jjtreeCloseNodeScope(jjtn001);
    }
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FORALL:
      ForAll();
      break;
    default:
      jj_la1[10] = jj_gen;
      ;
    }
  }

  final public void Add() throws ParseException {
    SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTEXPR_OPERATOR);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);
    try {
      jj_consume_token(ADD);
                                          ((ExprNode) jjtn001).setName(getToken(0).image);
                                          ((ExprNode) jjtn001).setInfixOperatorFlag(false);
      Expression();
      jj_consume_token(TO);
      Reference();
    } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte001;}
    }
    if (jjte001 instanceof ParseException) {
      {if (true) throw (ParseException)jjte001;}
    }
    {if (true) throw (Error)jjte001;}
    } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001,  true);
      jjtreeCloseNodeScope(jjtn001);
    }
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FORALL:
      ForAll();
      break;
    default:
      jj_la1[11] = jj_gen;
      ;
    }
  }

  final public void Compatible() throws ParseException {
    SimpleNode jjtn003 = (SimpleNode)SimpleNode.jjtCreate(this, JJTEXPR_COMPATIBLE);
    boolean jjtc003 = true;
    jjtree.openNodeScope(jjtn003);
    jjtreeOpenNodeScope(jjtn003);
    try {
      jj_consume_token(COMPATIBLE);
      SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTEXPR_ITERATOR);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
      try {
        jj_consume_token(FORMAL_IDENTIFIER);
                                   ((ExprNode)jjtn001).setArgument(getToken(0).image);
        jj_consume_token(OF);
        Reference();
      } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte001;}
      }
      if (jjte001 instanceof ParseException) {
        {if (true) throw (ParseException)jjte001;}
      }
      {if (true) throw (Error)jjte001;}
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  true);
        jjtreeCloseNodeScope(jjtn001);
      }
      }
      label_2:
      while (true) {
        SimpleNode jjtn002 = (SimpleNode)SimpleNode.jjtCreate(this, JJTEXPR_ITERATOR);
        boolean jjtc002 = true;
        jjtree.openNodeScope(jjtn002);
        jjtreeOpenNodeScope(jjtn002);
        try {
          jj_consume_token(COMMA);
          jj_consume_token(FORMAL_IDENTIFIER);
                                     ((ExprNode)jjtn002).setArgument(getToken(0).image);
          jj_consume_token(OF);
          Reference();
        } catch (Throwable jjte002) {
        if (jjtc002) {
          jjtree.clearNodeScope(jjtn002);
          jjtc002 = false;
        } else {
          jjtree.popNode();
        }
        if (jjte002 instanceof RuntimeException) {
          {if (true) throw (RuntimeException)jjte002;}
        }
        if (jjte002 instanceof ParseException) {
          {if (true) throw (ParseException)jjte002;}
        }
        {if (true) throw (Error)jjte002;}
        } finally {
        if (jjtc002) {
          jjtree.closeNodeScope(jjtn002,  true);
          jjtreeCloseNodeScope(jjtn002);
        }
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[12] = jj_gen;
          break label_2;
        }
      }
      Where();
    } catch (Throwable jjte003) {
    if (jjtc003) {
      jjtree.clearNodeScope(jjtn003);
      jjtc003 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte003 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte003;}
    }
    if (jjte003 instanceof ParseException) {
      {if (true) throw (ParseException)jjte003;}
    }
    {if (true) throw (Error)jjte003;}
    } finally {
    if (jjtc003) {
      jjtree.closeNodeScope(jjtn003,  true);
      jjtreeCloseNodeScope(jjtn003);
    }
    }
  }

  final public void Call() throws ParseException {
    SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTEXPR_CALL);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);
    try {
      jj_consume_token(CALL);
              ((ExprNode) jjtn001).setName(getToken(0).image);
              ((ExprNode) jjtn001).setInfixOperatorFlag(false);
      Method();
      jj_consume_token(WHEN);
      Event();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IN:
        jj_consume_token(IN);
        EventScope();
        break;
      default:
        jj_la1[13] = jj_gen;
        ;
      }
    } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte001;}
    }
    if (jjte001 instanceof ParseException) {
      {if (true) throw (ParseException)jjte001;}
    }
    {if (true) throw (Error)jjte001;}
    } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001,  true);
      jjtreeCloseNodeScope(jjtn001);
    }
    }
  }

  final public void Method() throws ParseException {
    SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTEXPR_METHOD);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);
    try {
      jj_consume_token(SIMPLE_IDENTIFIER);
                        ((ExprNode) jjtn001).setName(getToken(0).image);
                        ((ExprNode) jjtn001).setInfixOperatorFlag(false);
      Arguments();
    } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte001;}
    }
    if (jjte001 instanceof ParseException) {
      {if (true) throw (ParseException)jjte001;}
    }
    {if (true) throw (Error)jjte001;}
    } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001,  true);
      jjtreeCloseNodeScope(jjtn001);
    }
    }
  }

  final public void Event() throws ParseException {
    SimpleNode jjtn002 = (SimpleNode)SimpleNode.jjtCreate(this, JJTEXPR_EVENT);
    boolean jjtc002 = true;
    jjtree.openNodeScope(jjtn002);
    jjtreeOpenNodeScope(jjtn002);
    try {
      jj_consume_token(SIMPLE_IDENTIFIER);
                        ((ExprNode) jjtn002).setName(getToken(0).image);
                        ((ExprNode) jjtn002).setInfixOperatorFlag(false);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 74:
        jj_consume_token(74);
        jj_consume_token(TEXT_LITERAL);
                       ((ExprNode) jjtn002).setCommandName(getToken(0).image);
                        SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTEXPR_LITERAL);
                        boolean jjtc001 = true;
                        jjtree.openNodeScope(jjtn001);
                        jjtreeOpenNodeScope(jjtn001);
        try {
                        jjtree.closeNodeScope(jjtn001,  true);
                        jjtc001 = false;
                        jjtreeCloseNodeScope(jjtn001);
                       ((ExprNode) jjtn001).setInfixOperatorFlag(false);
        } finally {
                        if (jjtc001) {
                          jjtree.closeNodeScope(jjtn001,  true);
                          jjtreeCloseNodeScope(jjtn001);
                        }
        }
        break;
      default:
        jj_la1[14] = jj_gen;
        ;
      }
    } finally {
    if (jjtc002) {
      jjtree.closeNodeScope(jjtn002,  true);
      jjtreeCloseNodeScope(jjtn002);
    }
    }
  }

  final public void EventScope() throws ParseException {
    SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTEXPR_EVENTSCOPE);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);
    try {
      jj_consume_token(SIMPLE_IDENTIFIER);
                        ((ExprNode) jjtn001).setName(getToken(0).image);
                         jjtree.closeNodeScope(jjtn001,  true);
                         jjtc001 = false;
                         jjtreeCloseNodeScope(jjtn001);
                        ((ExprNode) jjtn001).setInfixOperatorFlag(false);
    } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001,  true);
      jjtreeCloseNodeScope(jjtn001);
    }
    }
  }

  final public void SystemArgument() throws ParseException {
    jj_consume_token(SYSTEM_PARAMETER);
                      SimpleNode jjtn002 = (SimpleNode)SimpleNode.jjtCreate(this, JJTEXPR_SYSTEMARGUMENT);
                      boolean jjtc002 = true;
                      jjtree.openNodeScope(jjtn002);
                      jjtreeOpenNodeScope(jjtn002);
    try {
      jj_consume_token(LPAREN);
      jj_consume_token(TEXT_LITERAL);
                                         ((ExprNode) jjtn002).setName(getToken(0).image);
                                          SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTEXPR_LITERAL);
                                          boolean jjtc001 = true;
                                          jjtree.openNodeScope(jjtn001);
                                          jjtreeOpenNodeScope(jjtn001);
      try {
                                          jjtree.closeNodeScope(jjtn001,  true);
                                          jjtc001 = false;
                                          jjtreeCloseNodeScope(jjtn001);
                                         ((ExprNode) jjtn001).setInfixOperatorFlag(false);
      } finally {
                                          if (jjtc001) {
                                            jjtree.closeNodeScope(jjtn001,  true);
                                            jjtreeCloseNodeScope(jjtn001);
                                          }
      }
      jj_consume_token(RPAREN);
    } finally {
                      if (jjtc002) {
                        jjtree.closeNodeScope(jjtn002,  true);
                        jjtreeCloseNodeScope(jjtn002);
                      }
    }
  }

  final public void EventArgument() throws ParseException {
    jj_consume_token(EVENT_PARAMETER);
                     SimpleNode jjtn002 = (SimpleNode)SimpleNode.jjtCreate(this, JJTEXPR_EVENTARGUMENT);
                     boolean jjtc002 = true;
                     jjtree.openNodeScope(jjtn002);
                     jjtreeOpenNodeScope(jjtn002);
    try {
      jj_consume_token(LPAREN);
      jj_consume_token(TEXT_LITERAL);
                                        ((ExprNode) jjtn002).setName(getToken(0).image);
                                          SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTEXPR_LITERAL);
                                          boolean jjtc001 = true;
                                          jjtree.openNodeScope(jjtn001);
                                          jjtreeOpenNodeScope(jjtn001);
      try {
                                          jjtree.closeNodeScope(jjtn001,  true);
                                          jjtc001 = false;
                                          jjtreeCloseNodeScope(jjtn001);
                                         ((ExprNode) jjtn001).setInfixOperatorFlag(false);
      } finally {
                                          if (jjtc001) {
                                            jjtree.closeNodeScope(jjtn001,  true);
                                            jjtreeCloseNodeScope(jjtn001);
                                          }
      }
      jj_consume_token(RPAREN);
    } finally {
                     if (jjtc002) {
                       jjtree.closeNodeScope(jjtn002,  true);
                       jjtreeCloseNodeScope(jjtn002);
                     }
    }
  }

/* Iterators */
  final public void ForAll() throws ParseException {
                                     Node node = jjtree.popNode();
    SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTEXPR_FOR_ALL);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);
    try {
      jj_consume_token(FORALL);
      Iterator();
      label_3:
      while (true) {
        if (jj_2_1(2)) {
          ;
        } else {
          break label_3;
        }
        jj_consume_token(COMMA);
        Iterator();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WHERE:
        Where();
        break;
      default:
        jj_la1[15] = jj_gen;
        ;
      }
                                     jjtree.pushNode(node);
                                      jjtree.closeNodeScope(jjtn001,  true);
                                      jjtc001 = false;
                                      jjtreeCloseNodeScope(jjtn001);

    } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte001;}
    }
    if (jjte001 instanceof ParseException) {
      {if (true) throw (ParseException)jjte001;}
    }
    {if (true) throw (Error)jjte001;}
    } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001,  true);
      jjtreeCloseNodeScope(jjtn001);
    }
    }
  }

  final public void Where() throws ParseException {
    SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTEXPR_WHERE);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);
    try {
      jj_consume_token(WHERE);
      Expression();
    } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte001;}
    }
    if (jjte001 instanceof ParseException) {
      {if (true) throw (ParseException)jjte001;}
    }
    {if (true) throw (Error)jjte001;}
    } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001,  true);
      jjtreeCloseNodeScope(jjtn001);
    }
    }
  }

  final public void Iterator() throws ParseException {
    SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTEXPR_ITERATOR);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);
    try {
      jj_consume_token(FORMAL_IDENTIFIER);
                                     ((ExprNode) jjtn001).setArgument(getToken(0).image);
      jj_consume_token(IN);
      if (jj_2_2(2)) {
        CollectionExpression();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACKET:
          CollectionLiteral();
          break;
        default:
          jj_la1[16] = jj_gen;
          if (jj_2_3(2)) {
            TemplateApplication();
                                           jjtree.closeNodeScope(jjtn001,  true);
                                           jjtc001 = false;
                                           jjtreeCloseNodeScope(jjtn001);
                                          validateCollection((ExprNode) jjtn001, (ExprNode) jjtn001, true);
          } else {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case SIMPLE_IDENTIFIER:
            case FORMAL_IDENTIFIER:
            case QUOTED_IDENTIFIER:
              Reference();
                    jjtree.closeNodeScope(jjtn001,  true);
                    jjtc001 = false;
                    jjtreeCloseNodeScope(jjtn001);
                   validateCollection((ExprNode) jjtn001, (ExprNode) jjtn001, false);
              break;
            default:
              jj_la1[17] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        }
      }
    } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte001;}
    }
    if (jjte001 instanceof ParseException) {
      {if (true) throw (ParseException)jjte001;}
    }
    {if (true) throw (Error)jjte001;}
    } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001,  true);
      jjtreeCloseNodeScope(jjtn001);
    }
    }
  }

/* Expressions */
  final public void Expression() throws ParseException {
    OrExpression();
  }

  final public void OrExpression() throws ParseException {
  String op = null;
          SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTEXPR_OPERATOR);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
          jjtreeOpenNodeScope(jjtn001);
    try {
      AndExpression();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OR:
        jj_consume_token(OR);
                                         op = getToken(0).image; ((ExprNode) jjtn001).setName(op);
        OrExpression();
        break;
      default:
        jj_la1[18] = jj_gen;
        ;
      }
    } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte001;}
          }
          if (jjte001 instanceof ParseException) {
            {if (true) throw (ParseException)jjte001;}
          }
          {if (true) throw (Error)jjte001;}
    } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  op != null);
            jjtreeCloseNodeScope(jjtn001);
          }
    }
  }

  final public void AndExpression() throws ParseException {
  String op = null;
    SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTEXPR_OPERATOR);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);
    try {
      EqualityExpression();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
        jj_consume_token(AND);
                                         op = getToken(0).image; ((ExprNode) jjtn001).setName(op);
        AndExpression();
        break;
      default:
        jj_la1[19] = jj_gen;
        ;
      }
    } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte001;}
    }
    if (jjte001 instanceof ParseException) {
      {if (true) throw (ParseException)jjte001;}
    }
    {if (true) throw (Error)jjte001;}
    } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001,  op != null);
      jjtreeCloseNodeScope(jjtn001);
    }
    }
  }

  final public void EqualityExpression() throws ParseException {
  String op = null;
    SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTEXPR_OPERATOR);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);
    try {
      RelationalExpression();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQUALS:
      case NOT_EQUALS:
      case LIKE:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EQUALS:
          jj_consume_token(EQUALS);
          break;
        case NOT_EQUALS:
          jj_consume_token(NOT_EQUALS);
          break;
        case LIKE:
          jj_consume_token(LIKE);
          break;
        default:
          jj_la1[20] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                                             op = getToken(0).image; ((ExprNode) jjtn001).setName(op);
        EqualityExpression();
        break;
      default:
        jj_la1[21] = jj_gen;
        ;
      }
    } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte001;}
    }
    if (jjte001 instanceof ParseException) {
      {if (true) throw (ParseException)jjte001;}
    }
    {if (true) throw (Error)jjte001;}
    } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001,  op != null);
      jjtreeCloseNodeScope(jjtn001);
    }
    }
  }

  final public void RelationalExpression() throws ParseException {
  String op = null;
          SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTEXPR_OPERATOR);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
          jjtreeOpenNodeScope(jjtn001);
    try {
      AdditiveExpression();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case GT:
      case GE:
      case LT:
      case LE:
      case SUBSETOF:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case GT:
          jj_consume_token(GT);
          break;
        case GE:
          jj_consume_token(GE);
          break;
        case LT:
          jj_consume_token(LT);
          break;
        case LE:
          jj_consume_token(LE);
          break;
        case SUBSETOF:
          jj_consume_token(SUBSETOF);
          break;
        default:
          jj_la1[22] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                                                        op = getToken(0).image; ((ExprNode) jjtn001).setName(op);
        RelationalExpression();
        break;
      default:
        jj_la1[23] = jj_gen;
        ;
      }
    } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte001;}
          }
          if (jjte001 instanceof ParseException) {
            {if (true) throw (ParseException)jjte001;}
          }
          {if (true) throw (Error)jjte001;}
    } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  op != null);
            jjtreeCloseNodeScope(jjtn001);
          }
    }
  }

/**
Precedence: *, /, %, +, -
Left Associativity:*, /, %, +, -
Right Associativity: !, =, >, >=,  <, <=
*/
  final public void AdditiveExpression() throws ParseException {
    MultiplicativeExpression();
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
      case MINUS:
        ;
        break;
      default:
        jj_la1[24] = jj_gen;
        break label_4;
      }
        SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTEXPR_OPERATOR);
        boolean jjtc001 = true;
        jjtree.openNodeScope(jjtn001);
        jjtreeOpenNodeScope(jjtn001);
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PLUS:
          jj_consume_token(PLUS);
          break;
        case MINUS:
          jj_consume_token(MINUS);
          break;
        default:
          jj_la1[25] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                                             ((ExprNode) jjtn001).setName(getToken(0).image);
        MultiplicativeExpression();
      } catch (Throwable jjte001) {
        if (jjtc001) {
          jjtree.clearNodeScope(jjtn001);
          jjtc001 = false;
        } else {
          jjtree.popNode();
        }
        if (jjte001 instanceof RuntimeException) {
          {if (true) throw (RuntimeException)jjte001;}
        }
        if (jjte001 instanceof ParseException) {
          {if (true) throw (ParseException)jjte001;}
        }
        {if (true) throw (Error)jjte001;}
      } finally {
        if (jjtc001) {
          jjtree.closeNodeScope(jjtn001,  2);
          jjtreeCloseNodeScope(jjtn001);
        }
      }
    }
  }

  final public void MultiplicativeExpression() throws ParseException {
    UnaryExpression();
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MULTIPLY:
      case DIVIDE:
      case ZDIV:
      case MOD:
        ;
        break;
      default:
        jj_la1[26] = jj_gen;
        break label_5;
      }
        SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTEXPR_OPERATOR);
        boolean jjtc001 = true;
        jjtree.openNodeScope(jjtn001);
        jjtreeOpenNodeScope(jjtn001);
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MULTIPLY:
          jj_consume_token(MULTIPLY);
          break;
        case DIVIDE:
          jj_consume_token(DIVIDE);
          break;
        case ZDIV:
          jj_consume_token(ZDIV);
          break;
        case MOD:
          jj_consume_token(MOD);
          break;
        default:
          jj_la1[27] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                                                     ((ExprNode) jjtn001).setName(getToken(0).image);
        UnaryExpression();
      } catch (Throwable jjte001) {
        if (jjtc001) {
          jjtree.clearNodeScope(jjtn001);
          jjtc001 = false;
        } else {
          jjtree.popNode();
        }
        if (jjte001 instanceof RuntimeException) {
          {if (true) throw (RuntimeException)jjte001;}
        }
        if (jjte001 instanceof ParseException) {
          {if (true) throw (ParseException)jjte001;}
        }
        {if (true) throw (Error)jjte001;}
      } finally {
        if (jjtc001) {
          jjtree.closeNodeScope(jjtn001,  2);
          jjtreeCloseNodeScope(jjtn001);
        }
      }
    }
  }

  final public void UnaryExpression() throws ParseException {
  boolean plus = true;
    SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTEXPR_OPERATOR);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
      case MINUS:
      case NOT:
      case NOTTRUE:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PLUS:
          jj_consume_token(PLUS);
          break;
        case MINUS:
          jj_consume_token(MINUS);
          break;
        case NOT:
          jj_consume_token(NOT);
          break;
        case NOTTRUE:
          jj_consume_token(NOTTRUE);
          break;
        default:
          jj_la1[28] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                                                              ((ExprNode) jjtn001).setName(getToken(0).image);
                                        plus = getToken(0).image.equals("+");
        break;
      default:
        jj_la1[29] = jj_gen;
        ;
      }
      ExponentExpression();
    } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte001;}
    }
    if (jjte001 instanceof ParseException) {
      {if (true) throw (ParseException)jjte001;}
    }
    {if (true) throw (Error)jjte001;}
    } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001,  ! plus);
      jjtreeCloseNodeScope(jjtn001);
    }
    }
  }

  final public void ExponentExpression() throws ParseException {
  String op = null;
    SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTEXPR_OPERATOR);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);
    try {
      PrimaryExpression();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXP:
        jj_consume_token(EXP);
                                                 op = getToken(0).image; ((ExprNode) jjtn001).setName(op);
        ExponentExpression();
        break;
      default:
        jj_la1[30] = jj_gen;
        ;
      }
    } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte001;}
    }
    if (jjte001 instanceof ParseException) {
      {if (true) throw (ParseException)jjte001;}
    }
    {if (true) throw (Error)jjte001;}
    } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001,  op != null);
      jjtreeCloseNodeScope(jjtn001);
    }
    }
  }

  final public void PrimaryExpression() throws ParseException {
    if (jj_2_4(2)) {
      CollectionExpression();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TEXT_LITERAL:
      case INTEGER_LITERAL:
      case DECIMAL_LITERAL:
      case BOOLEAN_LITERAL:
      case LBRACKET:
        Literal();
        break;
      case LPAREN:
        jj_consume_token(LPAREN);
        Expression();
        jj_consume_token(RPAREN);
        break;
      case SYSTEM_PARAMETER:
        SystemArgument();
        break;
      case EVENT_PARAMETER:
        EventArgument();
        break;
      default:
        jj_la1[31] = jj_gen;
        if (jj_2_5(2)) {
          TemplateApplication();
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SIMPLE_IDENTIFIER:
          case FORMAL_IDENTIFIER:
          case QUOTED_IDENTIFIER:
            Reference();
            break;
          default:
            jj_la1[32] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
    }
  }

  final public void CollectionExpression() throws ParseException {
    jj_consume_token(LBRACKET);
    jj_consume_token(COLLECT);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DISTINCT:
      jj_consume_token(DISTINCT);
                                   SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTEXPR_DISTINCT);
                                   boolean jjtc001 = true;
                                   jjtree.openNodeScope(jjtn001);
                                   jjtreeOpenNodeScope(jjtn001);
      try {
                                   jjtree.closeNodeScope(jjtn001,  true);
                                   jjtc001 = false;
                                   jjtreeCloseNodeScope(jjtn001);
                                  ((ExprNode) jjtn001).setName(getToken(0).image);
      } finally {
                                   if (jjtc001) {
                                     jjtree.closeNodeScope(jjtn001,  true);
                                     jjtreeCloseNodeScope(jjtn001);
                                   }
      }
      break;
    default:
      jj_la1[33] = jj_gen;
      ;
    }
    Expression();
    ForAll();
    jj_consume_token(RBRACKET);
  }

  final public void Literal() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTEXPR_LITERAL);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
      try {
        jj_consume_token(INTEGER_LITERAL);
                           ((ExprNode) jjtn001).setNumValue(getToken(0).image);
                            jjtree.closeNodeScope(jjtn001,  true);
                            jjtc001 = false;
                            jjtreeCloseNodeScope(jjtn001);
                           ((ExprNode) jjtn001).setDataType(ExprNode.DATA_TYPE_INTEGER);
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  true);
        jjtreeCloseNodeScope(jjtn001);
      }
      }
      break;
    case DECIMAL_LITERAL:
      SimpleNode jjtn002 = (SimpleNode)SimpleNode.jjtCreate(this, JJTEXPR_LITERAL);
      boolean jjtc002 = true;
      jjtree.openNodeScope(jjtn002);
      jjtreeOpenNodeScope(jjtn002);
      try {
        jj_consume_token(DECIMAL_LITERAL);
                           ((ExprNode) jjtn002).setNumValue(getToken(0).image);
                            jjtree.closeNodeScope(jjtn002,  true);
                            jjtc002 = false;
                            jjtreeCloseNodeScope(jjtn002);
                           ((ExprNode) jjtn002).setDataType(ExprNode.DATA_TYPE_DECIMAL);
      } finally {
      if (jjtc002) {
        jjtree.closeNodeScope(jjtn002,  true);
        jjtreeCloseNodeScope(jjtn002);
      }
      }
      break;
    case BOOLEAN_LITERAL:
      SimpleNode jjtn003 = (SimpleNode)SimpleNode.jjtCreate(this, JJTEXPR_LITERAL);
      boolean jjtc003 = true;
      jjtree.openNodeScope(jjtn003);
      jjtreeOpenNodeScope(jjtn003);
      try {
        jj_consume_token(BOOLEAN_LITERAL);
                           ((ExprNode) jjtn003).setTextValue(getToken(0).image);
                            jjtree.closeNodeScope(jjtn003,  true);
                            jjtc003 = false;
                            jjtreeCloseNodeScope(jjtn003);
                           ((ExprNode) jjtn003).setDataType(ExprNode.DATA_TYPE_BOOLEAN);
      } finally {
      if (jjtc003) {
        jjtree.closeNodeScope(jjtn003,  true);
        jjtreeCloseNodeScope(jjtn003);
      }
      }
      break;
    case TEXT_LITERAL:
      SimpleNode jjtn004 = (SimpleNode)SimpleNode.jjtCreate(this, JJTEXPR_LITERAL);
      boolean jjtc004 = true;
      jjtree.openNodeScope(jjtn004);
      jjtreeOpenNodeScope(jjtn004);
      try {
        jj_consume_token(TEXT_LITERAL);
                           String val = getToken(0).image; val = val.substring(1,val.length()-1);
                           ((ExprNode) jjtn004).setTextValue(val);
                            jjtree.closeNodeScope(jjtn004,  true);
                            jjtc004 = false;
                            jjtreeCloseNodeScope(jjtn004);
                           ((ExprNode) jjtn004).setDataType(ExprNode.DATA_TYPE_TEXT);
      } finally {
      if (jjtc004) {
        jjtree.closeNodeScope(jjtn004,  true);
        jjtreeCloseNodeScope(jjtn004);
      }
      }
      break;
    case LBRACKET:
      CollectionLiteral();
      break;
    default:
      jj_la1[34] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void Arguments() throws ParseException {
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TEXT_LITERAL:
    case INTEGER_LITERAL:
    case DECIMAL_LITERAL:
    case BOOLEAN_LITERAL:
    case PLUS:
    case MINUS:
    case NOT:
    case NOTTRUE:
    case FUNC_PTR:
    case LPAREN:
    case LBRACKET:
    case SYSTEM_PARAMETER:
    case EVENT_PARAMETER:
    case SIMPLE_IDENTIFIER:
    case FORMAL_IDENTIFIER:
    case QUOTED_IDENTIFIER:
      ExpressionList();
      break;
    default:
      jj_la1[35] = jj_gen;
      ;
    }
    jj_consume_token(RPAREN);
  }

  final public void ExpressionList() throws ParseException {
    ExpressionElement();
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[36] = jj_gen;
        break label_6;
      }
      jj_consume_token(COMMA);
      ExpressionElement();
    }
  }

  final public void ExpressionElement() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FUNC_PTR:
      SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTEXPR_TEMPLATE);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
      try {
        jj_consume_token(FUNC_PTR);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SIMPLE_IDENTIFIER:
        case FORMAL_IDENTIFIER:
        case QUOTED_IDENTIFIER:
          TemplateIdentifier();
          break;
        case PLUS:
        case MINUS:
        case MULTIPLY:
        case DIVIDE:
        case ZDIV:
        case MOD:
        case EXP:
        case EQUALS:
        case NOT_EQUALS:
        case GT:
        case GE:
        case LT:
        case LE:
        case NOT:
        case NOTTRUE:
        case AND:
        case OR:
        case LIKE:
        case ADD:
        case SUBTRACT:
        case CONTRIBUTE:
        case COMPATIBLE:
        case REQUIRES:
        case IMPLIES:
        case EXCLUDES:
        case NEGATES:
        case DEFAULTS:
          AnyOperator();
          break;
        default:
          jj_la1[37] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                          jjtree.closeNodeScope(jjtn001, true);
                          jjtc001 = false;
                          jjtreeCloseNodeScope(jjtn001);
                         ((ExprNode) jjtn001).setName(getToken(0).image);
      } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte001;}
      }
      if (jjte001 instanceof ParseException) {
        {if (true) throw (ParseException)jjte001;}
      }
      {if (true) throw (Error)jjte001;}
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
        jjtreeCloseNodeScope(jjtn001);
      }
      }
      break;
    case TEXT_LITERAL:
    case INTEGER_LITERAL:
    case DECIMAL_LITERAL:
    case BOOLEAN_LITERAL:
    case PLUS:
    case MINUS:
    case NOT:
    case NOTTRUE:
    case LPAREN:
    case LBRACKET:
    case SYSTEM_PARAMETER:
    case EVENT_PARAMETER:
    case SIMPLE_IDENTIFIER:
    case FORMAL_IDENTIFIER:
    case QUOTED_IDENTIFIER:
      Expression();
      break;
    default:
      jj_la1[38] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void CollectionLiteral() throws ParseException {
                                   int elements = jjtree.nodeArity();
    jj_consume_token(LBRACKET);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TEXT_LITERAL:
    case INTEGER_LITERAL:
    case DECIMAL_LITERAL:
    case BOOLEAN_LITERAL:
    case PLUS:
    case MINUS:
    case NOT:
    case NOTTRUE:
    case FUNC_PTR:
    case LPAREN:
    case LBRACKET:
    case SYSTEM_PARAMETER:
    case EVENT_PARAMETER:
    case SIMPLE_IDENTIFIER:
    case FORMAL_IDENTIFIER:
    case QUOTED_IDENTIFIER:
      ExpressionList();
      break;
    default:
      jj_la1[39] = jj_gen;
      ;
    }
    jj_consume_token(RBRACKET);
                                         chainElements(jjtree.nodeArity() - elements);
  }

  final public void TemplateApplication() throws ParseException {
    SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTEXPR_OPERATOR);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);
    try {
      TemplateIdentifier();
                                         ((ExprNode) jjtn001).setName(getToken(0).image);
                                         ((ExprNode) jjtn001).setInfixOperatorFlag(false);
                                         ((ExprNode) jjtn001).setTemplateApplicationFlag(true);
      Arguments();
                                  jjtree.closeNodeScope(jjtn001,  true);
                                  jjtc001 = false;
                                  jjtreeCloseNodeScope(jjtn001);

    } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte001;}
    }
    if (jjte001 instanceof ParseException) {
      {if (true) throw (ParseException)jjte001;}
    }
    {if (true) throw (Error)jjte001;}
    } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001,  true);
      jjtreeCloseNodeScope(jjtn001);
    }
    }
  }

/* Identifiers */
  final public void Reference() throws ParseException {
          SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTEXPR_REFNODE);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
          jjtreeOpenNodeScope(jjtn001);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SIMPLE_IDENTIFIER:
      case QUOTED_IDENTIFIER:
        ModelIdentifier();
        label_7:
        while (true) {
          if (jj_2_6(2147483647) && (getToken(3).kind != LPAREN)) {
            ;
          } else {
            break label_7;
          }
          jj_consume_token(DOT);
          ModelIdentifier();
        }
        label_8:
        while (true) {
          if (jj_2_7(3)) {
            ;
          } else {
            break label_8;
          }
          jj_consume_token(DOT);
          SysPropIdentifier();
        }
        if (jj_2_8(2)) {
          jj_consume_token(DOT);
          UserPropIdentifier();
        } else {
          ;
        }
        break;
      case FORMAL_IDENTIFIER:
        ArgumentIdentifier();
        label_9:
        while (true) {
          if (jj_2_9(2)) {
            ;
          } else {
            break label_9;
          }
          jj_consume_token(DOT);
          SysPropIdentifier();
        }
        if (jj_2_10(2)) {
          jj_consume_token(DOT);
          UserPropIdentifier();
        } else {
          ;
        }
        break;
      default:
        jj_la1[40] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte001;}
          }
          if (jjte001 instanceof ParseException) {
            {if (true) throw (ParseException)jjte001;}
          }
          {if (true) throw (Error)jjte001;}
    } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  true);
            jjtreeCloseNodeScope(jjtn001);
          }
    }
  }

  final public void UserPropIdentifier() throws ParseException {
          SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTEXPR_PROP);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
          jjtreeOpenNodeScope(jjtn001);
    try {
      jj_consume_token(USER_PROP_IDENTIFIER);
      jj_consume_token(LPAREN);
      jj_consume_token(TEXT_LITERAL);
                                   String img = getToken(0).image;
                                   ((ExprNode) jjtn001).setName(img.substring(1,img.length()-1));
                                   ((ExprNode) jjtn001).setSourcePosition(getToken(0).offset, img.length());
      jj_consume_token(RPAREN);
    } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  true);
            jjtreeCloseNodeScope(jjtn001);
          }
    }
  }

  final public void SysPropIdentifier() throws ParseException {
    SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTEXPR_SYS_PROP);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);
    try {
      jj_consume_token(SIMPLE_IDENTIFIER);
                         ((ExprNode) jjtn001).setName(getToken(0).image);
      Arguments();
    } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte001;}
    }
    if (jjte001 instanceof ParseException) {
      {if (true) throw (ParseException)jjte001;}
    }
    {if (true) throw (Error)jjte001;}
    } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001,  true);
      jjtreeCloseNodeScope(jjtn001);
    }
    }
  }

  final public void ModelIdentifier() throws ParseException {
  String name = null;
          SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTEXPR_PSNODE);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
          jjtreeOpenNodeScope(jjtn001);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SIMPLE_IDENTIFIER:
        jj_consume_token(SIMPLE_IDENTIFIER);
                                 name = processEscapeChar(getToken(0).image);
        break;
      case QUOTED_IDENTIFIER:
        jj_consume_token(QUOTED_IDENTIFIER);
                                 name = getToken(0).image; name = processEscapeChar(name.substring(1,name.length()-1));
        break;
      default:
        jj_la1[41] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                             ((ExprNode) jjtn001).setName(name);
                             ((ExprNode) jjtn001).setDataType(ExprNode.DATA_TYPE_NODE);
                                                                                          jjtree.closeNodeScope(jjtn001,  true);
                                                                                          jjtc001 = false;
                                                                                          jjtreeCloseNodeScope(jjtn001);

    } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  true);
            jjtreeCloseNodeScope(jjtn001);
          }
    }
  }

  final public void ArgumentIdentifier() throws ParseException {
    jj_consume_token(FORMAL_IDENTIFIER);
                         SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTEXPR_ARGUMENT);
                         boolean jjtc001 = true;
                         jjtree.openNodeScope(jjtn001);
                         jjtreeOpenNodeScope(jjtn001);
    try {
                         jjtree.closeNodeScope(jjtn001,  true);
                         jjtc001 = false;
                         jjtreeCloseNodeScope(jjtn001);
                        ((ExprNode) jjtn001).setArgument(getToken(0).image);
    } finally {
                         if (jjtc001) {
                           jjtree.closeNodeScope(jjtn001,  true);
                           jjtreeCloseNodeScope(jjtn001);
                         }
    }
  }

  final public void TemplateIdentifier() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SIMPLE_IDENTIFIER:
      jj_consume_token(SIMPLE_IDENTIFIER);
      break;
    case FORMAL_IDENTIFIER:
      jj_consume_token(FORMAL_IDENTIFIER);
      break;
    case QUOTED_IDENTIFIER:
      jj_consume_token(QUOTED_IDENTIFIER);
      break;
    default:
      jj_la1[42] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void AnyOperator() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case REQUIRES:
    case IMPLIES:
    case EXCLUDES:
    case NEGATES:
    case DEFAULTS:
      ConstrainingOperator();
      break;
    case CONTRIBUTE:
      jj_consume_token(CONTRIBUTE);
      break;
    case COMPATIBLE:
      jj_consume_token(COMPATIBLE);
      break;
    case ADD:
      jj_consume_token(ADD);
      break;
    case SUBTRACT:
      jj_consume_token(SUBTRACT);
      break;
    case PLUS:
      jj_consume_token(PLUS);
      break;
    case MINUS:
      jj_consume_token(MINUS);
      break;
    case MULTIPLY:
      jj_consume_token(MULTIPLY);
      break;
    case DIVIDE:
      jj_consume_token(DIVIDE);
      break;
    case ZDIV:
      jj_consume_token(ZDIV);
      break;
    case MOD:
      jj_consume_token(MOD);
      break;
    case EXP:
      jj_consume_token(EXP);
      break;
    case EQUALS:
      jj_consume_token(EQUALS);
      break;
    case NOT_EQUALS:
      jj_consume_token(NOT_EQUALS);
      break;
    case GT:
      jj_consume_token(GT);
      break;
    case GE:
      jj_consume_token(GE);
      break;
    case LT:
      jj_consume_token(LT);
      break;
    case LE:
      jj_consume_token(LE);
      break;
    case NOT:
      jj_consume_token(NOT);
      break;
    case NOTTRUE:
      jj_consume_token(NOTTRUE);
      break;
    case AND:
      jj_consume_token(AND);
      break;
    case OR:
      jj_consume_token(OR);
      break;
    case LIKE:
      jj_consume_token(LIKE);
      break;
    default:
      jj_la1[43] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  private boolean jj_3R_12() {
    if (jj_3R_16()) return true;
    if (jj_3R_17()) return true;
    return false;
  }

  private boolean jj_3_3() {
    if (jj_3R_12()) return true;
    return false;
  }

  private boolean jj_3R_14() {
    if (jj_scan_token(SIMPLE_IDENTIFIER)) return true;
    if (jj_3R_17()) return true;
    return false;
  }

  private boolean jj_3_2() {
    if (jj_3R_11()) return true;
    return false;
  }

  private boolean jj_3R_15() {
    if (jj_scan_token(USER_PROP_IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_10() {
    if (jj_scan_token(FORMAL_IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_11() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(COLLECT)) return true;
    return false;
  }

  private boolean jj_3_6() {
    if (jj_scan_token(DOT)) return true;
    if (jj_3R_13()) return true;
    return false;
  }

  private boolean jj_3_1() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_10()) return true;
    return false;
  }

  private boolean jj_3_10() {
    if (jj_scan_token(DOT)) return true;
    if (jj_3R_15()) return true;
    return false;
  }

  private boolean jj_3_9() {
    if (jj_scan_token(DOT)) return true;
    if (jj_3R_14()) return true;
    return false;
  }

  private boolean jj_3_5() {
    if (jj_3R_12()) return true;
    return false;
  }

  private boolean jj_3R_16() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(69)) {
    jj_scanpos = xsp;
    if (jj_scan_token(70)) {
    jj_scanpos = xsp;
    if (jj_scan_token(71)) return true;
    }
    }
    return false;
  }

  private boolean jj_3_8() {
    if (jj_scan_token(DOT)) return true;
    if (jj_3R_15()) return true;
    return false;
  }

  private boolean jj_3_7() {
    if (jj_scan_token(DOT)) return true;
    if (jj_3R_14()) return true;
    return false;
  }

  private boolean jj_3_4() {
    if (jj_3R_11()) return true;
    return false;
  }

  private boolean jj_3R_17() {
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_19() {
    if (jj_scan_token(QUOTED_IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_18() {
    if (jj_scan_token(SIMPLE_IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_13() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_18()) {
    jj_scanpos = xsp;
    if (jj_3R_19()) return true;
    }
    return false;
  }

  /** Generated Token Manager. */
  public CDLParserTokenManager token_source;
  JavaCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[44];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x800ee000,0x0,0x800ee000,0x201,0x800ee000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6000000,0x6000000,0x78000000,0x78000000,0xc0000,0xc0000,0xf00000,0xf00000,0x800c0000,0x800c0000,0x1000000,0x2e000,0x0,0x0,0x2e000,0x800ee000,0x0,0xfffc0000,0x800ee000,0x800ee000,0x0,0x0,0x0,0xfffc0000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x400007e1,0x20000000,0x400007e1,0x0,0x400007e1,0x20,0x3e00000,0x1000,0x3e00000,0x1000,0x1000,0x1000,0x10000000,0x2000,0x0,0x4000,0x0,0x0,0x4,0x2,0x8,0x8,0x10,0x10,0x0,0x0,0x0,0x0,0x1,0x1,0x0,0x40000000,0x0,0x10000,0x0,0x44000001,0x10000000,0x3e003cf,0x44000001,0x44000001,0x0,0x0,0x0,0x3e003cf,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0xf9,0x0,0xf9,0x0,0xf9,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400,0x0,0x1,0xe0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x19,0xe0,0x0,0x1,0xf9,0x0,0xe0,0xf9,0xf9,0xe0,0xa0,0xe0,0x0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[10];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public CDLParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public CDLParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new CDLParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 44; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 44; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public CDLParser(java.io.Reader stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new CDLParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 44; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 44; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public CDLParser(CDLParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 44; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(CDLParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 44; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[75];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 44; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 75; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 10; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
